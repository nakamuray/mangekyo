.\" Automatically generated by Pandoc 1.19.2.1
.\"
.TH "MGK" "1" "Apr 2017" "" ""
.hy
.SH NAME
.PP
mangekyo \- lenses within pipes
.SH DESCRIPTION
.PP
mangekyo is a tool to process JSON and other format of data stream,
through lenses within pipes.
.SH INSTALL
.PP
mangekyo is written by haskell.
You can use stack (https://www.haskellstack.org/) to build and install
it.
.IP
.nf
\f[C]
$\ cd\ mangekyo
$\ stack\ setup
$\ stack\ install
\f[]
.fi
.SH EXAMPLES
.PP
hello world:
.IP
.nf
\f[C]
$\ mgk\ \[aq]yield\ "hello\ world"`
"hello\ world"
\f[]
.fi
.PP
extract \f[C]name\f[] from JSON stream:
.IP
.nf
\f[C]
$\ echo\ \[aq]{"name":"roi"}{"name":"zak"}\[aq]\ |\ mgk\ \[aq]map\ {\ _^.\@name\ }\[aq]
"roi"
"zak"
\f[]
.fi
.PP
extract from nested object:
.IP
.nf
\f[C]
$\ echo\ \[aq]{"user":{"name":"nakamuray"}}\[aq]\ |\ mgk\ \[aq]map\ {\ _^.\@user.\@name\ }\[aq]
"nakamuray"
\f[]
.fi
.PP
sum \f[C]value\f[]:
.IP
.nf
\f[C]
$\ echo\ \[aq]{"value":1}{"value":2}{"value":3}\[aq]\ |\ mgk\ \[aq]map\ {\ _^.\@value\ }\ |\ each\ {\ \@sum\ +=\ _\ };\ yield\ sum\[aq]
6
\f[]
.fi
.PP
sum \f[C]value\f[], functional way:
.IP
.nf
\f[C]
$\ echo\ \[aq]{"value":1}{"value":2}{"value":3}\[aq]\ |\ mgk\ \[aq]map\ {\ _^.\@value\ }\ |\ fold\ (+)\ 0\ &\ yield\[aq]
6
\f[]
.fi
.SH DATA TYPES
.SS string
.IP
.nf
\f[C]
"hello\ world"
"\\u3042\\u3044\\u3046\\u3048\\u304a"
\f[]
.fi
.SS number
.IP
.nf
\f[C]
42
10.1
\f[]
.fi
.SS bool
.IP
.nf
\f[C]
true
false
\f[]
.fi
.SS null
.IP
.nf
\f[C]
null
\f[]
.fi
.SS array
.IP
.nf
\f[C]
[1,\ 2,\ 3]
\f[]
.fi
.SS object
.IP
.nf
\f[C]
{"key":\ "value"}
\f[]
.fi
.SS tuple
.IP
.nf
\f[C]
(1,\ 2,\ 3)
\f[]
.fi
.SS function
.IP
.nf
\f[C]
x\ \->\ y\ \->\ {\ x\ +\ y\ }
{\ _\ +\ 1\ }

#\ function\ call
f\ x
f\ x\ y
\f[]
.fi
.SS lens
.IP
.nf
\f[C]
\@x
at\ "x"
\f[]
.fi
.SH FUNCTIONS AND OPERATORS
.SS string :: value \-> string
.PP
Convert \f[C]value\f[] to string.
.SS number :: value \-> number
.PP
Convert \f[C]value\f[] to number.
.SS bool :: value \-> bool
.PP
Convert \f[C]value\f[] to bool.
.SS not :: value \-> bool
.PP
Negate boolean \f[C]value\f[].
.SS if :: bool \-> then_function \-> else_function
.PP
If \f[C]bool\f[] is true value, then call \f[C]then_function\f[], else
call \f[C]else_function\f[].
.SS when :: bool \-> function \-> value
.PP
If \f[C]bool\f[] is true value, then call \f[C]function\f[].
.SS unless :: bool \-> function \-> value
.PP
If \f[C]bool\f[] is false value, call \f[C]function\f[].
.SS pass :: () \-> null
.PP
Do nothing.
.SS exit :: number or () \-> ()
.PP
Exit with return code.
.SS id :: value \-> value
.PP
Return \f[C]value\f[] as is.
.SS const :: value \-> function
.PP
Return function which return \f[C]value\f[]
.SS for :: array \-> function \-> array
.PP
Call \f[C]function\f[] for each \f[C]array\f[] element, return array of
return values.
.SS items :: object \-> array
.PP
Return array of (key, value) tuple.
.SS fmt :: string \-> string
.PP
Format string with namespace variables.
.IP
.nf
\f[C]
$\ mgk\ \[aq]\@name\ .=\ "world";\ yield\ $\ fmt\ "hello\ #{name}"\[aq]
"hello\ world"
\f[]
.fi
.SS split :: sep_string \-> string \-> array
.PP
Split \f[C]string\f[] by \f[C]sep_string\f[].
.SS negative :: number \-> number
.PP
Negate a \f[C]number\f[].
.SS length :: value \-> number
.PP
Return length of \f[C]value\f[].
.SS system :: string_or_array \-> number
.PP
Execute system command and return exit status.
.SS p :: value \-> ()
.PP
Print \f[C]value\f[] directly (for debug purpose)
.SS . :: function \-> function \-> function
.PP
Compose functions (or lenses).
.SS $ :: function \-> value \-> value
.PP
Apply \f[C]function\f[] to the \f[C]value\f[].
.SS & :: value \-> function \-> value
.PP
Apply \f[C]function\f[] to the \f[C]value\f[].
.SS + :: value \-> value \-> value
.PP
Add values.
.SS * :: value \-> number \-> value
.PP
TODO.
.SS / :: number \-> number \-> number
.PP
TODO.
.SS == :: value \-> value \-> bool
.PP
Left \f[C]value\f[] equal right \f[C]value\f[].
.SS > :: value \-> value \-> bool
.PP
Left \f[C]value\f[] greater than right \f[C]value\f[].
.SS < :: value \-> value \-> bool
.PP
Left \f[C]value\f[] less than right \f[C]value\f[].
.SS >= :: value \-> value \-> bool: greater than equal
.PP
Left \f[C]value\f[] greater than equal right \f[C]value\f[].
.SS <= :: value \-> value \-> bool
.PP
Left \f[C]value\f[] less than equal right \f[C]value\f[].
.SS =~ :: string \-> regex_string \-> array
.PP
When \f[C]string\f[] match \f[C]regex_string\f[], return array of
matched string and captures.
if not, return null.
.SS !~ :: string \-> regex_string \-> bool
.PP
Not match the string.
this function return bool.
.SH PIPE FUNCTIONS
.PP
In addition to return value, functions could have side effects: consume
values from upstream, and produce value to downstream.
.PP
By default, upstream is \f[C]stdin\f[] and downstream is
\f[C]stdout\f[].
You can use \f[C]|\f[] to join functions, in such case left one is
upstream and right one is downstream.
.SS yield :: value \-> ()
.PP
Send a \f[C]value\f[] downstream.
.IP
.nf
\f[C]
$\ mgk\ \[aq]yield\ 42\[aq]
42
\f[]
.fi
.SS await :: () \-> value
.PP
Wait for a value from upstream.
.IP
.nf
\f[C]
$\ seq\ 10\ |\ mgk\ \[aq]yield\ $\ await()\[aq]
1
\f[]
.fi
.SS fold :: function \-> value \-> value
.PP
Fold input stream to value.
.IP
.nf
\f[C]
$\ seq\ 3\ |\ mgk\ \[aq]\@r\ .=\ fold\ (+)\ 0;\ yield\ r\[aq]
6
\f[]
.fi
.SS map :: function \-> ()
.PP
Apply \f[C]function\f[] to all values in a stream.
.IP
.nf
\f[C]
$\ seq\ 3\ |\ mgk\ \[aq]map\ {\ _\ *\ 2\ }\[aq]
2
4
6
\f[]
.fi
.SS filter :: function \-> ()
.PP
Filter stream by predicate \f[C]function\f[].
.IP
.nf
\f[C]
$\ seq\ 5\ |\ mgk\ \[aq]filter\ {\ _\ <\ 3\ }\[aq]
1
2
\f[]
.fi
.SS exclude :: function \-> ()
.PP
Exclude stream by predicate \f[C]function\f[].
.IP
.nf
\f[C]
$\ seq\ 5\ |\ mgk\ \[aq]exclude\ {\ _\ <\ 3\ }\[aq]
3
4
5
\f[]
.fi
.SS each :: function \-> ()
.PP
Apply \f[C]function\f[] for each value in a stream.
Don\[aq]t pass result values to downstream, by itself.
.IP
.nf
\f[C]
$\ seq\ 3\ |\ mgk\ \[aq]each\ {\ _\ *\ 2\ }\[aq]
$\ seq\ 3\ |\ mgk\ \[aq]each\ {\ yield\ $\ _\ *\ 2\ }\[aq]
2
4
6
\f[]
.fi
.SS concat :: () \-> ()
.PP
Convert stream of array of value, to stream of value.
.IP
.nf
\f[C]
$\ mgk\ \[aq]yield\ [1,\ 2,\ 3]\[aq]
[\ \ \ 
\ \ \ \ 1,
\ \ \ \ 2,
\ \ \ \ 3
]
$\ mgk\ \[aq]yield\ [1,\ 2,\ 3]\ |\ concat()\[aq]
1
2
3
\f[]
.fi
.SS consume :: () \-> array
.PP
Consume all values from stream and return as a array.
.IP
.nf
\f[C]
$\ seq\ 3\ |\ mgk\ \[aq]\@a\ .=\ consume();\ yield\ a\[aq]
[
\ \ \ \ 1,
\ \ \ \ 2,
\ \ \ \ 3
]
\f[]
.fi
.SS concatMap :: function \-> ()
.PP
Map a \f[C]function\f[] and concat a result.
.IP
.nf
\f[C]
$\ seq\ 3\ |\ mgk\ \[aq]concatMap\ {\ [_,\ _]\ }\[aq]
1
1
2
2
3
3
\f[]
.fi
.SS isolate :: number \-> ()
.PP
Isolate given number of items to downstream.
.IP
.nf
\f[C]
$\ seq\ 10\ |\ mgk\ \[aq]isolate\ 3\[aq]
1
2
3
\f[]
.fi
.SS chunksOf :: number \-> ()
.PP
Group a stream into chunks of given size.
.IP
.nf
\f[C]
$\ seq\ 4\ |\ mgk\ \[aq]chunksOf\ 2\[aq]
[
\ \ \ \ 1,
\ \ \ \ 2
]
[
\ \ \ \ 3,
\ \ \ \ 4
]
\f[]
.fi
.SS iterate :: function \-> value \-> ()
.PP
Produce an infinite stream of repeated application of function to value.
.IP
.nf
\f[C]
$\ mgk\ \[aq]iterate\ {\ _\ +\ 1\ }\ 0\[aq]
1
2
3
4
\&...
\f[]
.fi
.SS mergeSource :: function \-> ()
.PP
Call a function and merge it as a stream to upstream.
.IP
.nf
\f[C]
$\ seq\ 3\ |\ mgk\ \[aq]mergeSource\ {\ yield\ "a";\ yield\ "b"\ }\[aq]
[
\ \ \ \ "a",
\ \ \ \ 1
]
[
\ \ \ \ "b",
\ \ \ \ 2
]
\f[]
.fi
.SS merge :: function \-> ()
.PP
Alias for \f[C]mergeSource\f[].
.SS zipConduit :: function \-> function \-> (value, value)
.PP
Provide every values from upstream to both functions.
Return result of both functions.
.IP
.nf
\f[C]
$\ seq\ 5\ |\ mgk\ \[aq]\@r\ .=\ zipConduit\ {\ fold\ (+)\ 0\ }\ {\ fold\ (*)\ 1\ };\ yield\ r\[aq]
[\ \ \ 
\ \ \ \ 15,
\ \ \ \ 120
]
\f[]
.fi
.SS zip :: function \-> function \-> (value, value)
.PP
Alias for \f[C]zipConduit\f[].
.SS sourceArray :: array \-> ()
.PP
Provide each element of array to downstream.
.IP
.nf
\f[C]
$\ mgk\ \[aq]sourceArray\ [1,\ 2,\ 3]\[aq]
1
2
3
\f[]
.fi
.SS source :: array \-> ()
.PP
Alias for \f[C]sourceArray\f[].
.SS leftover :: value \-> ()
.PP
Get back a value to upstream, which to be consumed by next component.
.IP
.nf
\f[C]
$\ seq\ 3\ |\ mgk\ \[aq]leftover\ 10;\ map\ {\ _\ *\ 2\ }\[aq]
20
2
4
6
\f[]
.fi
.SS replicate :: number \-> value \-> ()
.PP
Replicate a value given number of times, provide those to downstream.
.IP
.nf
\f[C]
$\ mgk\ \[aq]replicate\ 3\ "hello"\[aq]
"hello"
"hello"
"hello"
\f[]
.fi
.SS peek :: () \-> value
.PP
Look at the next value in the upstream.
.SH LENS FUNCTIONS AND OPERATORS
.PP
mangekyo uses lens to get/set value from/to object and array.
It also use lens to modify namespace object.
.SS at :: value \-> lens
.PP
Create a \f[C]lens\f[] of given \f[C]value\f[].
.SS view :: object or array \-> lens \-> value
.PP
View \f[C]object\f[] or \f[C]array\f[] using \f[C]lens\f[].
.IP
.nf
\f[C]
$\ mgk\ \[aq]yield\ $\ view\ {"key":\ "value"}\ \@key\[aq]
"value"
$\ mgk\ \[aq]yield\ $\ view\ [1,\ 2,\ 3]\ \@1\[aq]
2
\f[]
.fi
.SS set :: lens or setter \-> value \-> object or array \-> value
.PP
Set \f[C]value\f[] to \f[C]object\f[] or \f[C]array\f[] using
\f[C]lens\f[].
.IP
.nf
\f[C]
$\ mgk\ \[aq]yield\ $\ set\ \@key\ "value"\ {}\[aq]
{
\ \ \ \ "key":\ "value"
}
\f[]
.fi
.SS over :: lens or setter \-> function \-> object or array \-> value
.PP
Call \f[C]function\f[] over the value lens views, replace it with result
value.
.IP
.nf
\f[C]
$\ mgk\ \[aq]yield\ $\ over\ \@key\ {\ _\ +\ 1\ }\ {"key":\ 1}\[aq]
{
\ \ \ \ "key":\ 2
}
\f[]
.fi
.SS mapped :: setter
.PP
Setter for each element of array.
.IP
.nf
\f[C]
$\ mgk\ \[aq]yield\ $\ set\ mapped\ 42\ [1,\ 2,\ 3]\[aq]
[
\ \ \ \ 42,
\ \ \ \ 42,
\ \ \ \ 42
]
$\ mgk\ \[aq]yield\ $\ over\ mapped\ {\ _\ +\ 1\ }\ [1,\ 2,\ 3]\[aq]\ \ 
[
\ \ \ \ 2,
\ \ \ \ 3,
\ \ \ \ 4
]
\f[]
.fi
.SS ^. :: object or array \-> value \-> value
.PP
Opereter version of \f[C]view\f[].
.IP
.nf
\f[C]
$\ mgk\ \[aq]yield\ $\ {"key":\ "value"}\ ^.\ \@key\[aq]
"value"
$\ mgk\ \[aq]yield\ $\ [1,\ 2,\ 3]\ ^.\ \@1\[aq]
2
\f[]
.fi
.SS .~ :: lens or setter \-> value \-> object or array \-> value
.PP
Operator version of \f[C]set\f[].
.IP
.nf
\f[C]
$\ mgk\ \[aq]yield\ $\ (\@key\ .~\ "value")\ {}\[aq]
{
\ \ \ \ "key":\ "value"
}
$\ mgk\ \[aq]yield\ $\ {}\ &\ \@key\ .~\ "value"\[aq]
{
\ \ \ \ "key":\ "value"
}
\f[]
.fi
.SS %~ :: lens or setter \-> function \-> value \-> value
.PP
Operator version of over.
.IP
.nf
\f[C]
$\ mgk\ \[aq]yield\ $\ (\@key\ %~\ {\ _\ +\ 1\ })\ {"key":\ 1}\[aq]
{
\ \ \ \ "key":\ 2
}
$\ mgk\ \[aq]yield\ $\ {"key":\ 1}\ &\ \@key\ %~\ {\ _\ +\ 1\ }\[aq]
{
\ \ \ \ "key":\ 2
}
\f[]
.fi
.SS .= :: lens or setter \-> value \-> value
.PP
\f[C]set\f[] to the target of lens within namespace object.
.IP
.nf
\f[C]
$\ mgk\ \[aq]\@x\ .=\ 10;\ yield\ x\[aq]
10
\f[]
.fi
.SS %= :: lens or setter \-> function \-> value
.PP
\f[C]over\f[] to the target of lens within namespace object.
.IP
.nf
\f[C]
$\ mgk\ \[aq]\@x\ .=\ 10;\ \@x\ %=\ {\ _\ +\ 1\ };\ yield\ x\[aq]
11
\f[]
.fi
.SS += :: lens or setter \-> value \-> value
.PP
Add \f[C]value\f[] to the target of lens within namespace object.
.SH AUTHORS
NAKAMURA Yoshitaka.
